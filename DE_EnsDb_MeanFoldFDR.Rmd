---
output: html_document
title: "Comparative analysis of Alignment/Mapping Pipelines in mouse CD4-positive T cells (Focused on Mean/Fold/FDR)"
author: "Mira Sohn" 
---

## Raw data 


#### - **GEO number**: [GSE128615](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE128615)

#### - **Study summary**: To determine the influence of differential Kdm6a expression in immune cells, whole transcriptome analysis for CD4+ T cells from WT and Kdm6a cKO mice were performed using RNA-Seq.

#### - **Reference**: [J Clin Invest. 2019 Aug 12;129(9):3852-3863. doi: 10.1172/JCI126250.](https://pubmed.ncbi.nlm.nih.gov/31403472)


```{r global_options, include=FALSE}


knitr::opts_chunk$set(
    warning=FALSE,
    message=FALSE
    )


```

## Loading packages

#### - **AnnotationHub**: https://bioconductor.org/packages/devel/bioc/vignettes/AnnotationHub/inst/doc/AnnotationHub.html

#### - **tximport**: https://bioconductor.org/packages/devel/bioc/vignettes/tximport/inst/doc/tximport.html

#### - **Rsubread**: https://bioconductor.org/packages/release/bioc/html/Rsubread.html

#### - **DESeq2**: http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html

```{r loading_packages}

library(data.table)
library(tidyverse)
library(rmarkdown)
library(ggplot2)
library(pheatmap)
library(AnnotationHub)
library(tximport)
library(Rsubread)
library(DESeq2)
library(UpSetR)
library(ensembldb)
library(gridExtra)
```

## Setting AnnotationHub

#### Assign your species of interest


```{r annotationhub_setup}

DB <- "EnsDb"
AnnotationSpecies <- "mus musculus"  # Assign your species 
ah <- AnnotationHub(hub=getAnnotationHubOption("URL"))  # Bring annotation DB

```


## Running AnnotationHub


```{r run_annotationhub}
ahQuery <- query(ah, 
                 pattern=c(DB, AnnotationSpecies), 
                 ignore.case=T)      # Filter annotation of interest


# Select the most recent data
DBName <- mcols(ahQuery) %>%
    rownames() %>%
    tail(1)

# Save the dataset of interest
AnnoDb <- ah[[DBName]] 

# Explore your EnsDb object with following accessors:
# columns(AnnpDb)
# keytypes(AnnoDb)
# keys(AnnoDb, keytype=..)
# select(AnnoDb, keys=.., columns=.., keytype=...)
AnnoKey <- keys(AnnoDb, keytype="TXID")
# Note: Annotation has to be done with not genome but transcripts 
AnnoDb <- select(AnnoDb, 
                 AnnoKey,
                 keytype="TXID",
                 columns=c("GENEID", "GENENAME")) 


# Check if your AnnoDb has been extracted and saved correctely
class(AnnoDb)
head(AnnoDb)    # The column 1 has to assign transcript (e.g. ENSEMBLTRANS)
```

## Metadata setting

```{r generating_metadata}
# This code chunk needs to be written by yourself 

# Define sample names 
SampleNames <- c(paste0("WT-rep", 1:3), paste0("cKO-rep", 1:3))  

# Aligner names
Aligners <- c("Salmon", "STAR", "HISAT2")

# Define group level
GroupLevel <- c("WT", "cKO")

# Define contrast for DE analysis
Contrast <- c("Group", GroupLevel)

# Set a function for file paths
path.fn <- function(head, tail) { 

    vec <- c(paste0("../", 
                    head,    # head = e.g. "hisat2", "star", or "salmon"
                    "_output/",
                    SampleNames,
                    tail))   # tail = file name after SampleNames 

    return(vec)
}


# Define .sf file path
sf <- path.fn("salmon",
              ".salmon_quant/quant.sf")


# Define STAR file path
star <- path.fn("star", 
                "Aligned.sortedByCoord.out.bam")

# Define HISAT2 file path
hisat <- path.fn("hisat2",
                 ".sorted.bam")


# Define sample groups
group <- c(rep(GroupLevel[1], 3), rep(GroupLevel[2], 3))

# Create metadata
metadata <- data.frame(Sample=factor(SampleNames, levels=SampleNames),
                       Group=factor(group, levels=GroupLevel),
                       Salmon_path=sf,
                       STAR_path=star, 
                       HISAT2_path=hisat)

# Assign row names with sample names
rownames(metadata) <- SampleNames


# Explore the metadata
print(metadata)


```


## featureCounts parameter setting

```{r featurecounts_parameters}

# "mm10", "mm9", "hg38", or "hg19"
# cf. mm10 = GRCm38
annot.inbuilt <- "mm10" 

# GTF file path
annot.ext <- "../../mouse_reference/gencode.m25.primary_assembly.annotation.gtf"

# annotation type:
# e.g.: "gene_id", "transcript_id", or "gene_name"
GTF.attrType <- "gene_id"

# Number of cores 
nthread <- 16 

# Set a function importing counts from BAM files with featureCounts()
fcounts.fn <- function(vec) {

    fc <- featureCounts(files=vec,   # a vector assigning BAM file paths
                         annot.inbuilt=annot.inbuilt,
                         annot.ext=annot.ext,
                         GTF.attrType=GTF.attrType,
                         isGTFAnnotationFile=T,
                         nthread=nthread, 
                         isPairedEnd=F, # Set this parameter correctly 
                         verbose=T)

    return(fc$counts)
}


```

## Importing counts 

### Importing Salmon counts

#### Note:     

#### txi1 <- tximport(..., txOut=F)   
#### txi2 <- tximport(..., txOut=T)     
#### txi2 <- summarizedToGene(...)    

#### counts extracted from txi1 and txi2 are the same 


```{r import_salmon}

# Import gene level summarized counts 
salmon.txi <- tximport(metadata$Salmon_path,
                       type = "salmon",
                       tx2gene=AnnoDb,
                       ignoreTxVersion=T, 
                       txOut=F)       # TRUE for transcript level, FALSE for gene level 

# Extract the counts and save as a data frame
salmon.counts <- salmon.txi$counts

# Explore the salmon count data frame
head(salmon.counts)
dim(salmon.counts)
summary(salmon.counts)

```

### Importing STAR counts


```{r import_star}

# Extract counts by running featureCounts() 
star.counts <- fcounts.fn(metadata$STAR_path)


# Explore the STAR count data frame
head(star.counts)
dim(star.counts)
summary(star.counts)

```


### Importing HISAT2 counts

```{r import_hisat2}

# Extract counts by running featureCounts() 
hisat2.counts <- fcounts.fn(metadata$HISAT2_path)

# Explore the HISAT2 count data frame
head(hisat2.counts)
dim(hisat2.counts)
summary(hisat2.counts)

```

## Data cleaning: sample and gene annotation


```{r count_dataframe_cleaning}

countList <- list(salmon.counts, 
                  star.counts,
                  hisat2.counts)

# Assign names of the count data frames in the count list
names(countList) <- Aligners

# Set a function cleaning the count data frame
clean.fn <- function(df) {

    # Convert to a data frame
    df <- as.data.frame(df)

    # Assign column names
    names(df) <- SampleNames

    # Bring row names to a column
    df <- df %>% rownames_to_column(var="GENEID")

    return(df)
}


# Set a function to drop GENEID version
clean.annotation.fn <- function(df) {

    # Re-annotate without version specification
    df <- separate(df, "GENEID", c("GENEID", "Version"))

    # Remove version column
    df <- df[, colnames(df) != "Version"]

    return(df)
}

# Move GENEID to a column
for (x in Aligners) {

    countList[[x]] <- clean.fn(countList[[x]])

}


# Remove version of GENEID and duplicated rows in STAR & HISAT2 count tables
for (x in Aligners) {

    countList[[x]] <- clean.annotation.fn(countList[[x]]) %>% 

        distinct()

}



# Explore the cleaned count data frames 
head(countList[[1]])
head(countList[[2]])
head(countList[[3]])
dim(countList[[1]])
dim(countList[[2]])
dim(countList[[3]])
sum(duplicated(countList[[1]]))
sum(duplicated(countList[[2]]))
sum(duplicated(countList[[3]]))


# Convert Salmon counts to integers 
countList[["Salmon"]] <- cbind(GENEID=countList[["Salmon"]][, "GENEID"],
                               round(countList[["Salmon"]][, 
                               colnames(countList[["Salmon"]]) %in% SampleNames]))

# Explore the cleaned count data frames 
head(countList[[1]])


```



## Plotting sequencing depth 

#### Number of total counts per sample

```{r library_size}

# Set a function generating a data frame with sequencing depth
seq.depth.fn <- function(df, aligner) {

    seqdf <- as.data.frame(colSums(df[, SampleNames])) %>% 
        rownames_to_column (var="Sample") %>% 
        mutate(Aligner=aligner)

    names(seqdf) <- c("Sample", "Count", "Aligner")

    return(seqdf)
}

# Set a function for a bar plot comparing values
comparing.barplot.fn <- function(df, yval, title, ytitle) {

    ggplot(df, 
       aes(x=Sample, y=yval, group=Aligner, fill=Aligner)) +
    geom_bar(stat="identity", position="dodge") +
    theme_bw() +
    ggtitle(title) + 
    ylab(ytitle)

}




# Initialize the seq depth data frame with the first aligner
seq.depth.df <- seq.depth.fn(countList[[1]], Aligners[1])

# Extend the seq depth data frame with the rest of aligners
for (x in Aligners) {

    if (x %in% Aligners[2:length(Aligners)]) {

        seq.depth.df <- rbind(seq.depth.df, 
                              seq.depth.fn(countList[[x]], x))
    }
}

# Explore how the data frame 
print(seq.depth.df)
summary(seq.depth.df)

# Convert character vectors to factors
seq.depth.df$Sample <- factor(seq.depth.df$Sample, 
                              levels=SampleNames)
seq.depth.df$Aligner <- factor(seq.depth.df$Aligner, 
                               levels=Aligners)

# Create a plot presenting sequencing depth
comparing.barplot.fn(seq.depth.df, 
                     seq.depth.df$Count, 
                     "Sequencing Depth by Sample and Aligner", 
                     "Count")

```

## Generating DESeq2 objects

#### - **vst()** was run to perform variance stabilizing transformation instead of rlog() which takes longer time with similar characteristics. 

#### - The **vsd** object created by vst() is used for not DE analysis but QC.

#### - References: [**DESeq2 doc "Transcript abundance files"**](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#tximport), [**DESeq2 doc "Variance stabilizing transformation"**](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#variance-stabilizing-transformation)

```{r generating_deseq2_objects}

# Initialize new lists for storing dds objects
ddsList <- countList

# Initialize new lists for storing vsd objects
vsdList <- countList


for (x in Aligners) {

    # Create a count matrix from the count data frame 
    m <- countList[[x]][, colnames(countList[[x]]) != "GENEID"] %>% 
        as.matrix()

    # Assigne row names
    rownames(m) <- countList[[x]]$GENEID

    # Generate a DESeq2 object
    ddsList[[x]] <- DESeqDataSetFromMatrix(m, 
                                           colData=metadata, 
                                           design=~Group) 

    # Conduct vst
    vsdList[[x]] <- varianceStabilizingTransformation(ddsList[[x]], 
                                                      blind=TRUE) 
}

# Explore generated objects
summary(ddsList)
summary(vsdList)


```


## Estimating size factors

#### - black dashed line: size factor = 1

#### - Reference: [**DESeq2 doc "Sample-/gene-dependent normalization factors"**](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#log-fold-change-shrinkage-for-visualization-and-ranking)


```{r size_factors}

# Calculate and add size factors to the DEseq object
for (x in Aligners) {

    ddsList[[x]] <- estimateSizeFactors(ddsList[[x]])

}

# Set a function summarizing size factors by aligner to a data frame
sfactor.fn <- function(df, aligner) {

    sizefactor <- as.data.frame(round(sizeFactors(df), 3)) %>%
        rownames_to_column(var="Sample") %>%
        mutate(Aligner=aligner)

    names(sizefactor) <- c("Sample", "Size_Factor", "Aligner")

    return(sizefactor)

}

# Initialize a data frame with the first aligner 
size.factor.df <- sfactor.fn(ddsList[[1]], Aligners[1])


for (x in Aligners) {

    if (x != Aligners[1]) {

        size.factor.df <- rbind(size.factor.df, 
                                sfactor.fn(ddsList[[x]], x))
    }
}


# Explore the data frame
print(size.factor.df)

# Convert character vectors to factors
size.factor.df$Sample <- factor(size.factor.df$Sample, 
                              levels=SampleNames)
size.factor.df$Aligner <- factor(size.factor.df$Aligner, 
                               levels=Aligners)

# Plot calculated size factors
comparing.barplot.fn(size.factor.df, 
                     size.factor.df$Size_Factor,  
                     "Size Factors by Aligner and Sample", 
                     "Size Factor") + geom_hline(yintercept=1, linetype="dashed", color="black", size=1)

```


## Estimating dispersion and Wald test

#### - **Dispersion** is calculated as a **measure of variation** instead of variance since variance gets larger when gene expression gets higher. 

#### - **Wald test** is the default setting of DESeq2 which tests null hypothesis between **two groups**. You should use **Likelihood ratio test (LRT)** when comparing **more than two groups**. 

#### - References: [**Harvard Chan Bioinformatics Core workshop I**](https://github.com/hbctraining/DGE_workshop_salmon_online/blob/master/lessons/05b_wald_test_results.md), [**Harvard Chan Bioinformatics Core workshop II**](https://github.com/hbctraining/DGE_workshop_salmon_online/blob/master/lessons/05a_hypothesis_testing.md), [**Harvard Chan Bioinformatics Core workshop III**](https://github.com/hbctraining/DGE_workshop_salmon_online/blob/master/lessons/04b_DGE_DESeq2_analysis.md), [**DESeq2 "Wald test indivisual steps**](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#wald-test-individual-steps), [**DESeq2 doc "Likelihood ratio test"**](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#likelihood-ratio-test)

```{r dispersion_waldtest}

for (x in Aligners) {

    # Dispersion
    ddsList[[x]] <- estimateDispersions(ddsList[[x]])
    
    # Wald test
    ddsList[[x]] <- nbinomWaldTest(ddsList[[x]])

}


# Explore generated data in the dds object 
ddsList[[1]]

```

## Sample QC: Principal Component Analysis (PCA)

#### Identifies source of variation and sample outliers

#### - Reference: [**DESeq2 doc "Principal component plot of the samples"**](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#principal-component-plot-of-the-samples), [**DESeq2 doc "Heatmap of the sample-to-sample distances"**](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#heatmap-of-the-sample-to-sample-distances)

```{r QC_PCA}

# Assigne what to compare
GroupOfInterest <- Contrast[1]


# Set a function for sample pca
qcpca.fn <- function(obj, title) {

    plotPCA(obj,
        intgroup=GroupOfInterest,
        returnData=FALSE) + theme_bw() + ggtitle(paste("PCA:", title)) 

}

# Print the plots
qcpca.fn(vsdList[[1]], Aligners[1]) 
qcpca.fn(vsdList[[2]], Aligners[2])
qcpca.fn(vsdList[[3]], Aligners[3]) 




```

## Sample QC: Sample Correlation Heatmap

#### Identifies distance between samples & correlation in a group

```{r QC_correlation_heatmap}

# Heatmap annotation
HeatmapAnno <- metadata[, c("Sample", "Group")]

# Set a function generating a correlation heatmap
cheatmap.fn <- function(df, title) {

    # Extract a normalized count matrix
    vm <- assay(df)

    # Generate a correlation matrix
    cm <- cor(vm)

    # Generate a heatmap
    pheatmap(cm, 
             annotation=HeatmapAnno, 
             main=paste("Sample Correlation Heatmap:", title))
}


# Print the heatmaps
cheatmap.fn(vsdList[[1]], Aligners[1])
cheatmap.fn(vsdList[[2]], Aligners[2])
cheatmap.fn(vsdList[[3]], Aligners[3])

```

## Running DE analysis


```{r DE_analysis}



# Run DESeq 
for (x in Aligners) {

    ddsList[[x]] <- DESeq(ddsList[[x]])
    # Check result names 
    ResNames <- resultsNames(ddsList[[x]])
    print(ResNames)

}


```

## Creating dispersion plots


#### - Dispersion is important since estimation by DESeq2 algorithm is based on the assumption that genes with similar expression levels have similar dispersion. If an RNA-seq dataset doesn't satisfy this assumption, use other DE algorithms than DESeq2. 

#### - References: [**DESeq2 doc "Dispersion plot and fitting alternatives**](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#dispersion-plot-and-fitting-alternatives), [**Harvard Chan Bioinformatics Core workshop **](https://github.com/hbctraining/DGE_workshop_salmon_online/blob/master/lessons/04b_DGE_DESeq2_analysis.md)

```{r dispersion_plot}

# Set a function plotting dispersion
dplot.fn <- function(dds, title) {

    plotDispEsts(dds, 
                 main=paste("Dispersion over Counts:", title))
}

# Plot dispersion patterns
dplot.fn(ddsList[[1]], Aligners[1])
dplot.fn(ddsList[[2]], Aligners[2])
dplot.fn(ddsList[[3]], Aligners[3])

# Do they fit well with the DESeq2 estimation model?

```

## Setting how to extract fold-change results

#### Change variables below

#### - The **alpha** denotes threshold of **false discovery rate (FDR)** assigned by users.

#### - In this analysis, the alpha is set to **0.1** 

```{r setting_resultcondition}

# Set FDR threshold alpha
alpha=0.1

# Set the coefficients to compare 
Coef <- ResNames[-1]
print(Coef) 



# Set a function to clean a result table 
lfctable.fn <- function(df) {
    df <- df %>% 
        rownames_to_column(var="GENEID") %>%
        mutate(FDR=ifelse(padj < 0.1 & !is.na(padj), 
                                   paste("<", alpha), 
                                   paste(">", alpha))) 
    return(df)
}

# Set a function extracting results
extract.lfc.fn <- function(dds) {

    res <- results(dds, contrast=Contrast, alpha=alpha)
    lfctable.fn(as.data.frame(res))

    return(lfctable.fn(as.data.frame(res)))


}

```


## Extracting log2FoldChanges

#### You can change alpha depending on your interest of FDR level

#### Shrinkage is NOT applied in this analysis



```{r DEresult_extraction}

# Initialize a list storing lfc data frames
lfcList <- countList

# Extract DE results
# The Contrast variable was defined in the previous chunk
# Extraction with no shrinkage
# alpha: FDR threshold
for (x in Aligners) {

    lfcList[[x]] <- extract.lfc.fn(ddsList[[x]]) %>% mutate(Alignment=x)

    print(head(lfcList[[x]]))

}

# Initialize a data frame storing total lfc results across the aligners
lfc.dataframe <- lfcList[[1]] 

for (x in Aligners[2:length(Aligners)]) {

    lfc.dataframe <- rbind(lfc.dataframe, 
                           lfcList[[x]])

}


lfc.dataframe$Alignment <- factor(lfc.dataframe$Alignment, 
                                  levels=Aligners)


```



## Exploring distribution of false discovery rate (FDR)

#### Black dashed line: FDR = 0.1

```{r FDR_distribution}

# Plot distribution of FDR 
ggplot(lfc.dataframe, 
       aes(x=padj, y=..count.., color=Alignment)) + 
    geom_density(size=1) + 
    theme_bw() + 
    scale_x_log10() + 
    ggtitle("Distribution of False Discovery Rate (FDR) by Aligner") + 
    ylab("Count") +
    xlim(0.00001, 1) + 
    geom_vline(xintercept=alpha, 
               color="black", 
               size=1, linetype="dashed") + scale_x_continuous(breaks=seq(0, 1, by=0.1))



```

## Presenting distribution of log2FoldChange

### Black: total genes (padj =/= NA)
### Colored: genes above or below FDR=0.1


```{r L2FC_distribution}

valid.lfc.df <- subset(lfc.dataframe, FDR == "< 0.1")

ggplot(valid.lfc.df,
       aes(x=log2FoldChange,
           y=..count.., 
           color=Alignment)) +
geom_density(size=1) + 
theme_bw() + 
geom_vline(xintercept=c(-1, 1), 
           linetype="dashed", color="black", size=1) + 
ggtitle("Distribution of log2FoldChange Values by Aligner (FDR < 0.1)") +
ylab("Count") + 
xlim(-10, 10)    # Change xlim by datatype

```


## Exploring mean-difference with an MA plot

#### - Reference: [**DESeq2 doc "MA-plot"**](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#ma-plot)

#### - **x-axis**: expression level (baseMean))

#### - **y-axis**: fold change (log2FoldChange)

#### - **Red dashed lines**: log2FoldChange = -1 and 1

```{r MAplot}

# Set ylim: has to adjusted by users depending on data 
yl <- c(-10, 10)

# Set min log2 fold change of interest 
mLog <- c(-1, 1)

# Create MA plots by Aligner
ggplot(lfc.dataframe, aes(x=baseMean, y=log2FoldChange, color=FDR)) + 
        geom_point() + 
        facet_grid(~Alignment) +
        scale_x_log10() + 
        theme_bw() + 
        scale_color_manual(values=c("blue", "grey")) + 
        ggtitle(paste("MA plot")) + 
        ylim(yl[1], yl[2]) + 
        theme(strip.text.x=element_text(size=10)) +
        geom_hline(yintercept=c(mLog[1], mLog[2]), 
                   linetype="dashed", color="red") 


```

## Exploring expression profiling with normalized count data

#### - Normalized count matrices are extracted from dds objects and filtered with thresholds set at FDR and log2FoldChange

#### - The heatmaps display **z-scores** of the normalized counts

#### - In this analysis, **mLog = 1**

#### - References: [**Harvard Chan Bioinformatics Core workshop**](https://github.com/hbctraining/DGE_workshop_salmon_online/blob/master/lessons/06_DGE_visualizing_results.md), [**DESeq2 doc "Heatmap of the count matrix"**](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#heatmap-of-the-count-matrix)

```{r expression_heatmap}

# Initialize a list 
heatmap.df.List <- lfcList

# Filter genes with FDR < alpha and absolute log2FoldChange > 1
for (x in Aligners) {

    # Set a logical vector filtering FDR below alpha
    is.fdr.valid <- lfcList[[x]]$FDR == paste("<", alpha)

    # Set a logical vector filtering absolute lfc above 1 
    is.lfc.large <- abs(lfcList[[x]]$log2FoldChange) > mLog[2]

    # Extract total normalized counts
    norm.counts <- counts(ddsList[[x]], normalized=T)

    # Save filtered genes only from the normalized count data
    heatmap.df.List[[x]] <- norm.counts[is.fdr.valid & is.lfc.large,]

}

# Explore the cleaned data frames 
head(heatmap.df.List[[1]])
head(heatmap.df.List[[2]])
head(heatmap.df.List[[3]])

dim(heatmap.df.List[[1]])
dim(heatmap.df.List[[2]])
dim(heatmap.df.List[[3]])

pheatmap(heatmap.df.List[[3]], 
         annotation=HeatmapAnno,
         scale="row",
         show_rownames=F)

# Set a function creating a profiling heatmap
profile.heatmap.fn <- function(df, title) {

    pheatmap(df, 
             annotation=HeatmapAnno, 
             scale="row", 
             show_rownames=F,
             main=paste("Expression Profiling by", title, "(FDR < 0.1, absolute log2FoldChange > 1)"))
}

# Print the expression heatmaps
profile.heatmap.fn(heatmap.df.List[[Aligners[1]]], Aligners[1])
profile.heatmap.fn(heatmap.df.List[[Aligners[2]]], Aligners[2])
profile.heatmap.fn(heatmap.df.List[[Aligners[3]]], Aligners[3])
```

## NA statistics: zero count genes & outlier genes

#### When NAs appear in  

#### - **log2FoldChange**: zero counts in all samples

#### - **padj**: too little information 

#### - **pval & padj**: at least one replicate was an outlier 

```{r NA_genes}

# Count number of NA genes  
type=c("Zero Counts", "Outliers", "Total NA Genes") 

# Create a data frame storing number of NA genes by type
NA.genes <- lfc.dataframe %>% 
    group_by(Alignment) %>% 
    summarize(zero=sum(is.na(log2FoldChange)), 
              outlier=sum(is.na(pvalue) & is.na(padj))) %>% 
    mutate(total=zero + outlier) %>%
    gather(Type, Number, -Alignment) %>% 
    mutate(Type=factor(case_when(Type == "zero" ~ type[1],
                                 Type == "outlier" ~ type[2],
                                 Type == "total" ~ type[3]),
                       levels=type))

# Plot number of NA genes 
ggplot(NA.genes, 
       aes(x=Type, y=Number, group=Alignment, fill=Alignment, label=Number)) + 
    geom_bar(stat="identity", position="dodge") + 
    theme_bw() +
    geom_text(position=position_dodge(width=1), vjust=1.5) + 
    ggtitle("Number of NA Genes") + 
    ylab("Number of Genes")


```


## baseMean/LFC/FDR comparison between aligners 





```{r diff_prep}



# Create a data frame storing the number of transcripts by gene id
AnnoDb.ntrans <- AnnoDb %>% 
    group_by(GENEID) %>% 
    summarize(num.trans=n_distinct(TXID))

# Create an empty list storing significant gene lfc tables 
sigList <- list() 


# Filter significant genes' lfc and save in the list 
for (x in Aligners) {


    sigList[[x]] <- subset(lfcList[[x]], FDR == paste("<", alpha))

}

# Create a vector storing column names
c_names <- colnames(sigList[[1]])[-1] 
c_names <- c("GENEID", 
             paste0(c_names, "_", Aligners[1]), 
             paste0(c_names, "_", Aligners[2]), 
             paste0(c_names, "_", Aligners[3]))


# Join tables by GENEID
lfcTable <- sigList[[1]] %>% 
    inner_join(sigList[[2]], by="GENEID") %>%
    inner_join(sigList[[3]], by="GENEID") 

# Rename the columns
names(lfcTable) <- c_names





# Calculate differences
lfcTable <- lfcTable %>%

    mutate(mean_SA_ST=baseMean_Salmon - baseMean_STAR,
           mean_SA_HI=baseMean_Salmon - baseMean_HISAT2,
           mean_ST_HI=baseMean_STAR - baseMean_HISAT2, 
           lfc_SA_ST=log2FoldChange_Salmon - log2FoldChange_STAR,
           lfc_SA_HI=log2FoldChange_Salmon - log2FoldChange_HISAT2,
           lfc_ST_HI=log2FoldChange_STAR - log2FoldChange_HISAT2,
           FDR_SA_ST=padj_Salmon - padj_STAR,
           FDR_SA_HI=padj_Salmon - padj_HISAT2, 
           FDR_ST_HI=padj_STAR - padj_HISAT2) %>% 

left_join(AnnoDb.ntrans, by="GENEID")


# Set a function to create a vector storing plot labels
plotlabels.fn <- function(myvec, mylist, num) {

    vec <- c()

    for (i in 1:num) {
        vec <- c(vec, c(myvec[i], rep("", nrow(mylist[[i]]) - 1)))
    }

    return(vec)

}



# Explore the output table
head(lfcTable)
dim(lfcTable)

```

```{r comparison_prep}


my.param <- c("baseMean", "log2FoldChange", "padj")


# Slice and clean the data frame for input
lfcTable.comp <- lfcTable %>% 
    dplyr::select(GENEID, num.trans, starts_with(my.param)) %>% 
    gather(Category, Value, -GENEID, -num.trans) %>% 
    separate(Category, c("Metric", "Aligner"), sep="_") %>% pivot_wider(names_from=Aligner, values_from=Value) %>% 
    group_by(Metric) %>%
    nest() %>% 

    # Calculate correlation coefficients between aligners by metric
    mutate(salmon.star.corr=map_dbl(data, ~ cor(.x$Salmon, .x$STAR)), 
           salmon.hisat.corr=map_dbl(data, ~ cor(.x$Salmon, .x$HISAT2)),
           star.hisat.corr=map_dbl(data, ~ cor(.x$STAR, .x$HISAT2))) 

# Explore the cleaned data frame
lfcTable.comp
lfcTable.comp$data

# Prep vectors storing the correlation coefficient without duplication by comparison
Rsquared.salmon.star <- plotlabels.fn(lfcTable.comp$salmon.star.corr, 
                          lfcTable.comp$data, 
                          nrow(lfcTable.comp))

Rsquared.salmon.hisat <- plotlabels.fn(lfcTable.comp$salmon.hisat.corr, 
                            lfcTable.comp$data,
                            nrow(lfcTable.comp))

Rsquared.star.hisat <- plotlabels.fn(lfcTable.comp$star.hisat.corr,
                            lfcTable.comp$data, 
                            nrow(lfcTable.comp))

# Unnest the data frame and add columns storing correlation coefficients each
lfcTable.comp <- lfcTable.comp %>% 
    unnest(data) 

head(lfcTable.comp)

lfcTable.comp$Rsquared.salmon.star <- Rsquared.salmon.star
lfcTable.comp$Rsquared.salmon.hisat <- Rsquared.salmon.hisat
lfcTable.comp$Rsquared.star.hisat <- Rsquared.star.hisat

# Explore the data frame
head(lfcTable.comp)


# Nest the data frame by Metric 
lfcTable.comp <- lfcTable.comp %>% 
    group_by(Metric) %>%
    nest()

# Explore the data frame
lfcTable.comp 
lfcTable.comp$data

# Set a function creating a scatter plot
comp.scatter.fn <- function(df, 
                            xvar, 
                            yvar, 
                            label, 
                            metric,
                            xlab, ylab,
                            xlog=F,
                            ylog=F) {

    p <- ggplot(df, aes(x=xvar, y=yvar, color=log(num.trans), label=label)) + 
        geom_point(alpha=0.5) + 
        theme_bw() + 
        geom_text(size=5, 
                  mapping=aes(x=Inf, y=Inf), 
                  vjust=2, hjust=1.2, color="black") +
geom_abline(slope=1, size=0.5, linetype="dashed", color="black") + 
ggtitle(paste("Comparison in", metric, "\n(with R-squared)")) + scale_color_gradient(low="blue", high="red") +
xlab(xlab) + 
ylab(ylab)

if (xlog) {

    p <- p + 
        scale_x_log10() 
}

if (ylog) { 

    p <- p + scale_y_log10()

}

return(p)
}

```


```{r comparison_plot, fig.width=12, fig.height=12}


# Create and add the scatter plots with or without logarithmic transformation of 
# x/y scales 
lfcTable.comp <- lfcTable.comp %>%

    # Add scatter plots to the data frame:
    #
    # without log transformation of x and y scales
    mutate(salmon.star=map(data, 
                           ~ comp.scatter.fn(.x, .x$Salmon, .x$STAR, 
                                             .x$Rsquared.salmon.star, Metric,
                                             "Salmon", "STAR")),

           salmon.hisat=map(data, ~ comp.scatter.fn(.x,
                                                    .x$Salmon,
                                                    .x$HISAT2, 
                                                    .x$Rsquared.salmon.hisat,
                                                    Metric, 
                                                    "Salmon", "HISAT2")),
           star.hisat=map(data, ~ comp.scatter.fn(.x, 
                                                  .x$STAR, 
                                                  .x$HISAT2, 
                                                  .x$Rsquared.star.hisat,
                                                  Metric,
                                                  "STAR", "HISAT2")),

           # with log transformation of x and y scales
           salmon.star.log=map(data, 
                           ~ comp.scatter.fn(.x, .x$Salmon, .x$STAR, 
                                             .x$Rsquared.salmon.star, Metric, 
                                             "Salmon", "STAR", 
                                             T, T)),

           salmon.hisat.log=map(data, ~ comp.scatter.fn(.x,
                                                    .x$Salmon,
                                                    .x$HISAT2, 
                                                    .x$Rsquared.salmon.hisat, 
                                                    Metric, 
                                                    "Salmon", "HISAT2",
                                                    T, T)),

           star.hisat.log=map(data, ~ comp.scatter.fn(.x, 
                                                  .x$STAR, 
                                                  .x$HISAT2, 
                                                  .x$Rsquared.star.hisat,
                                                  Metric, 
                                                  "STAR", "HISAT2",
                                                  T, T)))


# Set a function simplifying grid.arrange() function
gr.ar.fn0 <- function(pl1, pl2, pl3) {

    grid.arrange(pl1, pl2, pl3, ncol=1) 

}



# Print the plots
for (i in 1:length(my.param)) {

    p1 <- gr.ar.fn0(lfcTable.comp$salmon.star[[i]], 
                lfcTable.comp$salmon.hisat[[i]], 
                lfcTable.comp$star.hisat[[i]]) 


    p2 <- gr.ar.fn0(lfcTable.comp$salmon.star.log[[i]],
                lfcTable.comp$salmon.hisat.log[[i]],
                lfcTable.comp$star.hisat.log[[i]])

    print(grid.arrange(p1, p2, nrow=1)) 

}





```



## Relationship between baseMean/log2FoldChange/padj with the number of alternative transcripts 

#### - Variables of interest: baseMean, log2FoldChange, and padj 

#### - R-squared: tests whether the two variables are correlated

#### - None of the variable were correlated with the number of alternative transcripts in any of the aligners 

#### - ANOVA: tests whether the the variable is significantly different by Aligner 


```{r rel_with_ntrans}


# Slice the data frame 
lfcTable.rel <- lfcTable %>%
    dplyr::select(starts_with(c(my.param, "num.")))

# Set a function cleaning my data frame
gather.fn <- function(word) {

    gather(lfcTable.rel, Group, Value, starts_with(word)) %>%
        dplyr::select(Group, Value, num.trans)
}

# Set a function creating a boxplot
boxplot1.fn <- function(metric, ylog=F) {

    df <- subset(lfcTable.rela, Metric == metric)

p <- ggplot(df, 
            aes(x= Aligner, y=Value, fill=Aligner, label=ANOVA.pval)) + 
           geom_boxplot(alpha=0.5) + 
           theme_bw() + 
           xlab("Aligner") + 
           ylab("Value") + 
           theme(strip.text.x=element_text(size=10)) +
           ggtitle(paste("Aligner Comparison in", 
                         metric,
                         "\n(P-value from Two-Tailed ANOVA Test)")) + ylab(metric) + 
           geom_text(size=5, mapping=aes(x=Inf, y=Inf), vjust=2, hjust=1.2)

if (ylog) {

    p <- p + scale_y_log10()

}

return(p) 
}




# Clean the data frame 
lfcTable.rela <- rbind(gather.fn("base"), 
                       gather.fn("log2"), 
                       gather.fn("padj")) %>%

separate(Group, c("Metric", "Aligner"), sep="_") %>%

# Nest by Metric
group_by(Metric) %>%
nest() %>%

# Add columns storing: 
# 1. linear regression model 
# 2. summary of the model 
# 3. R-squared extracted from the model 
# 4. ANOVA test 
# 5. p-values extracted from the ANOVA objects
mutate(Model=map(data, ~ lm(Value ~ num.trans, data=.x)), 
       Model_Summary=map(Model, ~ summary(.x)),
       Rsquared=map_dbl(Model_Summary, ~ .x$r.squared), 
       ANOVA=map(data, ~ unlist(summary(aov(Value ~ Aligner, data=.x)))),
       ANOVA.pval=map_dbl(ANOVA, ~ round(.x["Pr(>F)1"], 9)))


# Create a vector storing p-values which will be used in plotting
ANOVA.pval <- plotlabels.fn(lfcTable.rela$ANOVA.pval, 
                            lfcTable.rela$data, 
                            nrow(lfcTable.rela))
# Unnest 
lfcTable.rela <- lfcTable.rela %>% 
    unnest(data) 

# Add a column storing previously created p-value vector
lfcTable.rela$ANOVA.pval <- ANOVA.pval


# Plot 
boxplot1.fn("baseMean", T) 
boxplot1.fn("log2FoldChange", T) 
boxplot1.fn("padj", F)
                 
```




## Difference comparison in baseMean/LFC/FDR between Aligners 


```{r difference, fid.width=12}



# Assign names of the list
col.of.int <- c("Subtraction", "Difference") 

# Slice and clean the data frame
lfcTable.diff <- dplyr::select(lfcTable, 
                               starts_with(c("mean_", 
                                             "lfc_", 
                                             "FDR_"))) %>% 
dplyr::select(-ends_with(c("Salmon", "STAR", "HISAT2")))

# Create an empty data frame 
lfcTable.sub <- data.frame() 

# Clean and save in the data frame
for (x in c("mean_", "lfc_", "FDR_")) {

    df <- lfcTable.diff %>%
    gather(Subtraction, Difference, starts_with(x)) %>%
    dplyr::select(col.of.int) 

if (x == "mean_") {

    lfcTable.sub <- df

} else {

    lfcTable.sub <- rbind(lfcTable.sub, df) 

}
}

# Explore the output 
head(lfcTable.sub)


# Rearrange the data frame 
lfcTable.sub <- lfcTable.sub %>% 
    separate(Subtraction, c("Metric", "From", "To"), sep="_") %>%

mutate(Metric=ifelse(Metric == "mean", "baseMean", 
                      ifelse(Metric == "lfc", "log2FoldChange", "padj")),
       From=ifelse(From == "SA", "Salmon", 
                   ifelse(From == "ST", "STAR", "HISAT2")),
       To=ifelse(To == "SA", "Salmon", 
                 ifelse(To == "ST", "STAR", "HISAT2")),

       Subtraction=paste(From, "-", To)) %>%

# Nest by Metric
group_by(Metric) %>%
nest() 

# Conduct ANOVA test in the subtraction data
lfcTable.sub <- lfcTable.sub %>%
    mutate(ANOVA=map(data, ~aov(Difference ~ Subtraction, data=.x)),
           ANOVA.summary=map(ANOVA, ~ unlist(summary(.x))),
           ANOVA.pval=map_dbl(ANOVA.summary, ~ .x["Pr(>F)1"]))

# Create a vector storing pvalue labels
sub.ANOVA.pval <- plotlabels.fn(lfcTable.sub$ANOVA.pval, 
                                lfcTable.sub$data, 
                                nrow(lfcTable.sub))

# Unnest the data frame 
lfcTable.sub <- lfcTable.sub %>% 
    unnest(data)

# Add a column storing pvalues
lfcTable.sub$ANOVA.pval <- sub.ANOVA.pval

# Set a function creating a box plot
boxplot2.fn <- function(metric, ylog=F) {

    df <- subset(lfcTable.sub, Metric == metric)

p <- ggplot(df, 
            aes(x= Subtraction, y=abs(Difference), 
                fill=Subtraction, label=ANOVA.pval)) + 
           geom_boxplot(alpha=0.5) + 
           theme_bw() + 
           xlab("Subtraction") + 
           ylab("Difference") + 
           theme(strip.text.x=element_text(size=10)) +
           ggtitle(paste("Subtraction Comparison in", 
                         metric,
                         "\n(P-value from Two-Tailed ANOVA Test)")) + 
           geom_text(size=5, mapping=aes(x=Inf, y=Inf), vjust=2, hjust=1.2)

if (ylog) {

    p <- p + scale_y_log10()

}

return(p) 
}


# Print the boxplots comparing subtraction & statistical significance by metric
boxplot2.fn("baseMean", T) 
boxplot2.fn("log2FoldChange", T) 
boxplot2.fn("padj", F) 


```





## Exploration of standard deviation (SD) of baseMean, log2FoldChange, and padj across the alingers

```{r plot_sd, fig.width=12}

# Create an empty data frame 
lfcTable.sd <- data.frame()

for (x in my.param) {

    # Slice the data frame with columns of interest
    df <- dplyr::select(lfcTable, 
                           starts_with(x)) 

    # Calculate Mean across the aligners
    df$Mean <- rowMeans(df)

    # Calculate SD across the aligners 
    df$SD <- apply(df[, 1:3], 1, sd)

    # Add a column storing the number of alternative transcripts
    df$num.trans <- lfcTable$num.trans 

    # Change column names
    colnames(df) <- str_replace(colnames(df), paste0(x, "_"), "")

    # Add a column storing metric 
    df$Metric <- x


    # Save as a data frame
    if (x == my.param[1]) {

        lfcTable.sd <- df 
        
    } else {

        lfcTable.sd <- rbind(lfcTable.sd, df) 

    }

}


# Explore the output data frame
head(lfcTable.sd)
dim(lfcTable.sd)


# Nest the data frame by Metric
lfcTable.sd <- lfcTable.sd %>% 
    group_by(Metric) %>%
    nest() 


# Explore the output data frame
lfcTable.sd 


# Set a function creating a scatter plot demonstrating SD over the number of alternative transcripts 
scatter1.fn <- function(df, mlog=F, ylog=F, metric) {

    if (mlog) {

        p <- ggplot(df, aes(x=num.trans, y=SD, color=log(Mean)))

    } else {

        p <- ggplot(df, aes(x=num.trans, y=SD, color=Mean))

    }

    p <- p + 
        geom_point(alpha=0.5) +
        theme_bw() +         
        xlab("Number of Transcripts") + 
ggtitle(paste("Relationship between", 
              metric, 
              "Standard Deviation and\nNumber of Transcripts")) +  
scale_color_gradient(low="blue", high="red")

if (ylog) {

    p <- p + 
        scale_y_log10() + 
        ylab("Log (Standard Deviation)")

} else {

    p <- p + ylab("Standard Deviation") 
}



return(p) 

}


# Create and save the scatter plots
lfcTable.sd <- lfcTable.sd %>%

    # sd.plot = No log transformation in the plot
    # sd.plot.logMean = log(Mean)
    # sd.plot.logY = log(SD), 
    # sd.plot.logBoth = log(Mean) & log(SD)
    mutate(sd.plot=map(data, ~ scatter1.fn(.x, F, F, Metric)),
           sd.plot.logMean=map(data, ~ scatter1.fn(.x, T, F, Metric)),
           sd.plot.logY=map(data, ~ scatter1.fn(.x, F, T, Metric)), 
           sd.plot.logBoth=map(data, ~ scatter1.fn(.x, T, T, Metric)))


# Set a function shortening scripts
gr.ar.fn2 <- function(pl1, pl2, pl3) {

    grid.arrange(pl1, pl2, pl3, nrow=1) 
}

# Explore the plots 
gr.ar.fn2(lfcTable.sd$sd.plot[[1]], 
          lfcTable.sd$sd.plot[[2]], 
          lfcTable.sd$sd.plot[[3]]) 


gr.ar.fn2(lfcTable.sd$sd.plot.logMean[[1]], 
             lfcTable.sd$sd.plot.logMean[[2]], 
             lfcTable.sd$sd.plot.logMean[[3]])

gr.ar.fn2(lfcTable.sd$sd.plot.logY[[1]], 
             lfcTable.sd$sd.plot.logY[[2]],
             lfcTable.sd$sd.plot.logY[[3]])

gr.ar.fn2(lfcTable.sd$sd.plot.logBoth[[1]],
             lfcTable.sd$sd.plot.logBoth[[2]], 
             lfcTable.sd$sd.plot.logBoth[[3]])


# Print the optimal presentation
gr.ar.fn2(lfcTable.sd$sd.plot.logBoth[[1]],
             lfcTable.sd$sd.plot.logBoth[[2]], 
             lfcTable.sd$sd.plot[[3]])

```


## Exploring relationship between difference/percent difference vs the number of alternative transcripts 



```{r percent_difference, fig.width=12, fig.height=12}

# Add columns storing percent difference
lfcTable <- lfcTable %>%

    # mDiff: difference in meanBase
    # lDiff: difference in log2FoldChange
    # fDiff: difference in padj (FDR)
    mutate(mDiff_percent=100 * mean_SA_ST / (baseMean_Salmon + baseMean_STAR),
           lDiff_percent=100 * lfc_SA_ST / (abs(log2FoldChange_Salmon) + abs(log2FoldChange_STAR)),
           fDiff_percent=100 * FDR_SA_ST / (padj_Salmon + padj_STAR))

# Explore the output
head(lfcTable)
dim(lfcTable)

# Create an empty data frame
lfcTable.percent <- data.frame()


for (x in my.param) {

    
    init.vec <- c("GENEID", "num.trans")

    # Set columns of interest
    if (x == my.param[1]) { 

        col.of.interest <- c(init.vec, "mean_SA_ST", "mDiff_percent")

    } else if (x == my.param[2]) {

        col.of.interest <- c(init.vec, "lfc_SA_ST", "lDiff_percent")

    } else {

        col.of.interest <- c(init.vec, "FDR_SA_ST", "fDiff_percent") 

    }



    # Trim the table 
    df <- lfcTable[, colnames(lfcTable) %in% col.of.interest] %>%
        mutate(Metric=x) %>%
        dplyr::rename(Difference=ends_with("ST"), 
                      Percent=ends_with("percent")) 

    # Save in the empty data frame 
    if (x == my.param[1]) {

        lfcTable.percent <- df

    } else {

        lfcTable.percent <- rbind(lfcTable.percent, df)

    }


}

# Explore the output
head(lfcTable.percent)
dim(lfcTable.percent)


# Nest the data frame by Metric
lfcTable.percent <- lfcTable.percent %>%
    group_by(Metric) %>%
    nest()

# Explore the output
lfcTable.percent
head(lfcTable.percent$data[[1]])


# Calculate correlation (Rsquared) 
# DvsP: Percent Difference vs Difference
# DvsT: Difference vs Number of Transcripts
# PvsT: Percent Difference vs Number of Transcripts
lfcTable.percent <- lfcTable.percent %>%
    mutate(DvsP.mod=map(data, ~ lm(Percent ~ Difference, data=.x)), 
           DvsP.rsq=map_dbl(DvsP.mod, ~ summary(.x)$r.squared),
           DvsT.mod=map(data, ~ lm(Difference ~ num.trans, data=.x)),
           DvsT.rsq=map_dbl(DvsT.mod, ~ summary(.x)$r.squared), 
           PvsT.mod=map(data, ~ lm(Percent ~ num.trans, data=.x)), 
           PvsT.rsq=map_dbl(PvsT.mod, ~ summary(.x)$r.squared))

# Add Rsquard values to the data frame as plot label columns
DvsP.r <- plotlabels.fn(lfcTable.percent$DvsP.rsq, 
                        lfcTable.percent$data, 
                        nrow(lfcTable.percent))

DvsT.r <- plotlabels.fn(lfcTable.percent$DvsT.rsq, 
                        lfcTable.percent$data, 
                        nrow(lfcTable.percent))

PvsT.r <- plotlabels.fn(lfcTable.percent$PvsT.rsq, 
                        lfcTable.percent$data, 
                        nrow(lfcTable.percent))

lfcTable.percent <- lfcTable.percent %>%
    unnest(data) 

lfcTable.percent$DvsP.Rsquared <- DvsP.r 
lfcTable.percent$DvsT.Rsquared <- DvsT.r
lfcTable.percent$PvsT.Rsquared <- PvsT.r


# Explore the output data frame
head(lfcTable.percent)

# Set a function creating scatter plot
scatter2.fn <- function(label.col, xtitle, ytitle, title, ylog=F, xlog=F, label=F) { 

p <- ggplot(lfcTable.percent) + 
theme_bw() + 
scale_color_gradient(low="blue", high="red") + 
facet_wrap(~Metric, scales = "free") + 
theme(strip.text.x=element_text(size=10)) + 
ggtitle(paste(title, "in Salmon vs STAR")) + 
xlab(xtitle) + 
ylab(ytitle)

if (ylog) {

    p <- p + scale_y_log10() + ylab(paste0("Log (", ytitle, ")")) 

} 

if (xlog) { 

    p <- p + scale_x_log10() + xlab(paste0("Log (", xtitle, ")")) 


}


if (label) {


p <- p + geom_text(data=lfcTable.percent, 
          size=5, 
          mapping=aes(label=label.col, x=Inf, y=Inf), 
          vjust=2, hjust=1.1, color="black") + 
ggtitle(paste(title, "in Salmon vs STAR", "(with R-Squared)"))
}



return(p)
}


# Create and save the plots
# P1 & 2: D vs P with or without log transformation of x values
# P3 & 4: P vs T with or without log transformation of y values
# P5 & 6: D vs T with or without log transformation of y values
p1 <- scatter2.fn(lfcTable.percent$DvsP.Rsquared, 
            "Salmon - STAR", 
            "100 x (Salmon - STAR) / (Salmon + STAR)", 
            "Difference vs Percent Difference", label=T) + 
geom_point(data=lfcTable.percent, alpha=0.5,
           aes(x=abs(Difference), y=abs(Percent), color=log(num.trans)))

p2 <- scatter2.fn(lfcTable.percent$DvsP.Rsquared, 
            "Salmon - STAR", 
            "100 x (Salmon - STAR) / (Salmon + STAR)", 
            "Difference vs Percent Difference", 
            xlog=T) + 
geom_point(data=lfcTable.percent, alpha=0.5,
           aes(x=abs(Difference), y=abs(Percent), color=log(num.trans)))


p3 <- scatter2.fn(lfcTable.percent$PvsT.Rsquared, 
            "Number of Alternative Transcripts", 
            "100 x (Salmon - STAR) / (Salmon + STAR)", 
            "Percent Difference vs Number of Alternative Transcripts",
            label=T) + 
    geom_point(data=lfcTable.percent, alpha=0.5,
               aes(x=num.trans, y=abs(Percent)))

p4 <- scatter2.fn(lfcTable.percent$PvsT.Rsquared, 
            "Number of Alternative Transcripts", 
            "100 x (Salmon - STAR) / (Salmon + STAR)", 
            "Percent Difference vs Number of Alternative Transcripts",
            ylog=T) + 
    geom_point(data=lfcTable.percent, alpha=0.5,
               aes(x=num.trans, y=abs(Percent)))

p5 <- scatter2.fn(lfcTable.percent$DvsT.Rsquared, 
            "Number of Alternative Transcripts", 
            "Salmon - STAR", 
            "Difference vs Number of Alternative Transcripts", 
            label=T) + 
    geom_point(data=lfcTable.percent, alpha=0.5,
               aes(x=num.trans, y=abs(Difference)))

p6 <- scatter2.fn(lfcTable.percent$DvsT.Rsquared, 
            "Number of Alternative Transcripts", 
            "Salmon - STAR", 
            "Difference vs Number of Alternative Transcripts",
            ylog=T) + 
    geom_point(data=lfcTable.percent, alpha=0.5,
               aes(x=num.trans, y=abs(Difference)))


# Print the plots
grid.arrange(p1, p2, ncol=1)
grid.arrange(p3, p4, ncol=1)
grid.arrange(p5, p6, ncol=1)




```


## Comparison of Ranking between Salmon and STAR in baseMean/log2FoldChange/FDR



```{r ranking_comparison_prep}

# Set a function rearranging a data frame
rank.fn <- function(df, var, desc=F) { 
    
    if (desc) { 

        df <- dplyr::arrange(df, desc(var)) 

    } else {

        df <- dplyr::arrange(df, var) 

    }


    return(df)

}


# Set a function creating a rank plot
rank.plot.fn <- function(df, metric, colog=F) { 


    if (colog) { 

        p <- ggplot(df, aes(x=Rank.x, 
                            y=Rank.y, 
                            color=log(MeanValue), 
                            label=Rsquared))

    } else {

        p <- ggplot(df, aes(x=Rank.x, 
                            y=Rank.y, 
                            color=MeanValue,
                            label=Rsquared))

    }
    
    p <- p + 
        geom_point(alpha=0.5) + 
        theme_bw() + 
        scale_color_gradient(low="blue", high="red") + 
        xlab("Salmon") + 
        ylab("STAR") + 
        ggtitle(paste("Rank Comparison in", metric, "\n(with R-Squared)")) + geom_text(size=5, 
                mapping=aes(x=Inf, y=Inf), vjust=2, hjust=1.0, color="black") +
geom_abline(slope=1, size=0.5, linetype="dashed", color="black")  

    return(p)

}


```


```{r ranking_comparison, fig.width=12}



# Clean the data frame 
lfcTable.rank <- lfcTable %>% 

    # Splice by columns of interest
    dplyr::select(GENEID, 
                  starts_with(c("baseMean_", "log2FoldChange_", "padj_")), 
                  -ends_with("HISAT2")) %>% 

# Reform the table
gather(Metric, Value, -GENEID) %>%

# Nest by Metric
group_by(Metric) %>%
nest() %>% 

# Add columns storing ascending or descending order by variable of interest
mutate(Ascending=map(data, ~ rank.fn(.x, .x$Value)), 
       Descending=map(data, ~ rank.fn(.x, .x$Value, T)),
       Final=map2(Ascending, 
                  Descending, 
                  ~ ifelse(Metric %in% c("padj_Salmon", "padj_STAR"),
                           Ascending, 
                           Descending)), 
       Final=map(Final, ~ .x[[1]]),

       # Add a column storing rank
       Final=map(Final, ~ mutate(.x, Rank=1:nrow(.x)))) %>%

# Unnest 
unnest(Final) %>% 

# Reform the table 
separate(Metric, c("Metric", "Aligner")) %>% 
dplyr::select(-data, -Ascending, -Descending) %>%

# Renest by metric
group_by(Metric) %>%
nest() %>%

# Reclean the data frame 
mutate(Split=map(data, ~ split(.x, .x$Aligner)),
       Joined=map(Split, ~ inner_join(.x[[1]], 
                                      .x[[2]], 
                                      by=c("GENEID")))) %>%
dplyr::select(-data, -Split) %>%

# Unnest
unnest(Joined) %>%

# Calculate and save MeanRank and MeanValue
mutate(MeanRank=(Rank.x + Rank.y)/2, 
       MeanValue=abs((Value.x + Value.y)/2)) %>% 


# Nest by Metric
nest(-Metric) %>%

# Add a column storing R^2
mutate(Rsquared=map_dbl(data, ~ cor(.x$Rank.x, .x$Rank.y)))

# Explore the data frame 
head(lfcTable.rank)
head(lfcTable.rank$data)



# Create a vector storing R^2 values as an input of ggplot2() 
Rsquared <- plotlabels.fn(lfcTable.rank$Rsquared, 
                          lfcTable.rank$data, 
                          nrow(lfcTable.rank))

# Unnest and add a column storing ggplot2's input R^2
lfcTable.rank <- lfcTable.rank %>%
    unnest(data) 

lfcTable.rank$Rsquared <- Rsquared


# Check out the new column added
head(lfcTable.rank)

# Clean the data frame
lfcTable.rank <- lfcTable.rank %>%

    # Nest by metric
    group_by(Metric) %>%
    nest() %>%

    # Add columns storing scatter plots
    mutate(RankPlot=map(data, ~ rank.plot.fn(.x, Metric)), 
           RankPlot.log=map(data, ~ rank.plot.fn(.x, Metric, T)))


# Set a function simplifying grid.arrange() 
gr.ar.fn3 <- function(pl1, pl2) {

    grid.arrange(pl1, pl2, nrow=1)

}


# Explore the plots
gr.ar.fn3(lfcTable.rank$RankPlot[[1]], 
                lfcTable.rank$RankPlot.log[[1]])

gr.ar.fn3(lfcTable.rank$RankPlot[[2]], 
                lfcTable.rank$RankPlot.log[[2]])

gr.ar.fn3(lfcTable.rank$RankPlot[[3]], 
                lfcTable.rank$RankPlot.log[[3]])



# Complete the optimal presentation for the plots
gr.ar.fn2(lfcTable.rank$RankPlot.log[[1]], 
          lfcTable.rank$RankPlot.log[[2]],
          lfcTable.rank$RankPlot[[3]])



```


## Saving gene rankings 


```{r saving_csv}

lfcTable.csv <- lfcTable %>%
    dplyr::select(GENEID, starts_with(my.param[-1])) %>% 
    gather(Category, Value, -GENEID) %>%
    separate(Category, c("Metric", "Aligner")) %>% 
    pivot_wider(names_from=Metric, values_from=Value) 

write.csv(lfcTable.csv, "lfcTable.csv") 

```


## Session Info

```{r session_info}

sessionInfo()

```
